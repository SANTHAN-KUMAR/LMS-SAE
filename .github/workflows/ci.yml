# ================================================
# CI Pipeline â€” Continuous Integration
# ================================================
# Runs on every push and pull request.
# Validates code quality, runs tests, and verifies
# the app can connect to the real Neon database.
#
# Required GitHub Secrets:
#   - DATABASE_URL   : Neon connection string
#   - SECRET_KEY     : App secret key
# ================================================

name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_call:
    secrets: inherit

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 1: Unit Tests (fast, no external deps)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  unit-tests:
    name: ðŸ§ª Unit Tests
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./exam_middleware

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: requirements.txt

      - name: Install system dependencies
        run: sudo apt-get update && sudo apt-get install -y libmagic1

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install aiosqlite python-magic

      - name: Run unit tests
        env:
          TESTING: "true"
          DATABASE_URL: "sqlite+aiosqlite:///:memory:"
          SECRET_KEY: "test-secret-key-for-ci"
          PYTHONPATH: ${{ github.workspace }}/exam_middleware
        run: pytest -v -m "unit or not (integration or e2e)" tests/unit/

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 2: Integration Test (real Neon DB)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  integration-test:
    name: ðŸ”Œ Neon DB Integration Test
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: requirements.txt

      - name: Install dependencies
        working-directory: ./exam_middleware
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Test real database connection
        working-directory: ./exam_middleware
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          TESTING: "false"
          PYTHONPATH: ${{ github.workspace }}/exam_middleware
        run: |
          python -c "
          import asyncio
          from app.db.database import engine
          from sqlalchemy import text

          async def test_connection():
              print('Connecting to Neon database...')
              async with engine.begin() as conn:
                  await conn.execute(text('SELECT 1'))
                  print('âœ… Database connection successful!')

                  tables = await conn.execute(text(
                      \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public'\"
                  ))
                  table_list = [row[0] for row in tables]
                  print(f'âœ… Found {len(table_list)} tables: {table_list}')

              await engine.dispose()
              print('âœ… Integration test passed!')

          asyncio.run(test_connection())
          "

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Job 3: Docker Build Smoke Test
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  docker-smoke-test:
    name: ðŸ³ Docker Build & Health Check
    runs-on: ubuntu-latest
    needs: unit-tests

    steps:
      - uses: actions/checkout@v4

      - name: Build Docker image
        run: docker build -t exam-app-test .

      - name: Boot container with real DB
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
        run: |
          docker run -d --name exam-test \
            -e DATABASE_URL="${DATABASE_URL}" \
            -e SECRET_KEY="${SECRET_KEY}" \
            -e DEBUG=false \
            -e MOODLE_BASE_URL=http://localhost \
            -p 8000:8000 \
            exam-app-test

          echo "â³ Waiting for app to start..."
          sleep 15

          if [ "$(docker inspect -f '{{.State.Running}}' exam-test)" != "true" ]; then
            echo "âŒ Container crashed!"
            docker logs exam-test
            exit 1
          fi

          echo "âœ… Container is running!"

      - name: Health check
        run: |
          HEALTH=$(docker exec exam-test curl -sf http://localhost:8000/health/health -o /dev/null -w "%{http_code}" || echo "failed")
          if [ "$HEALTH" = "200" ]; then
            echo "âœ… Health check passed!"
          else
            echo "âŒ Health check failed (HTTP $HEALTH)"
            docker logs exam-test --tail 50
            exit 1
          fi

      - name: Show logs on failure
        if: failure()
        run: docker logs exam-test 2>&1 || true

      - name: Cleanup
        if: always()
        run: |
          docker stop exam-test 2>/dev/null || true
          docker rm exam-test 2>/dev/null || true
